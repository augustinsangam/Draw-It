import * as tslib_1 from "tslib";
import { Component, ChangeDetectionStrategy, ChangeDetectorRef, EventEmitter, Input, Inject, Output, } from '@angular/core';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { EMPTY_COLOR } from './color-picker';
var MccColorPickerCollectionComponent = /** @class */ (function () {
    function MccColorPickerCollectionComponent(changeDetectorRef, emptyColor) {
        this.changeDetectorRef = changeDetectorRef;
        this.emptyColor = emptyColor;
        this._hideEmpty = false;
        /**
         * Size limit of the collection
         */
        this.size = 30;
        /**
         * Show transparent option
         */
        this.transparent = false;
        /**
         * Emit selected color value
         */
        this.changeColor = new EventEmitter();
    }
    Object.defineProperty(MccColorPickerCollectionComponent.prototype, "hideEmpty", {
        /**
         * Hide empty slots
         * Empty slots are the difference between the collection size and limit
         */
        set: function (value) {
            this._hideEmpty = coerceBooleanProperty(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MccColorPickerCollectionComponent.prototype, "label", {
        /**
         * Name of the collection
         */
        get: function () {
            return this._label;
        },
        set: function (value) {
            this._label = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MccColorPickerCollectionComponent.prototype, "colors", {
        /**
         * Array of colors to be displayed
         */
        get: function () {
            return this._colors;
        },
        set: function (values) {
            this._colors = values;
        },
        enumerable: true,
        configurable: true
    });
    MccColorPickerCollectionComponent.prototype.ngAfterContentChecked = function () {
        if (this._colors && this._colors.length !== this.size) {
            this._colors = this._colors
                .slice(0, this.size)
                .concat(new Array(this._getCollectionDiffSize()));
            this.changeDetectorRef.markForCheck();
        }
    };
    /**
     * Return the difference between the limit and the collection size.
     * Always return 0 when hideEmpty is true
     * @returns number
     */
    MccColorPickerCollectionComponent.prototype._getCollectionDiffSize = function () {
        if (this._colors.length > this.size || this._hideEmpty) {
            return 0;
        }
        return this.size - this._colors.length;
    };
    /**
     * Remove color
     */
    MccColorPickerCollectionComponent.prototype.setTransparent = function () {
        this.changeColor.emit(this.emptyColor);
    };
    /**
     * Emit selected color value
     * @param option MccColorPickerOption
     */
    MccColorPickerCollectionComponent.prototype.setColor = function (option) {
        var color = typeof option === 'string' ? option : option.value;
        this.changeColor.emit(color);
    };
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Boolean),
        tslib_1.__metadata("design:paramtypes", [Boolean])
    ], MccColorPickerCollectionComponent.prototype, "hideEmpty", null);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", String),
        tslib_1.__metadata("design:paramtypes", [String])
    ], MccColorPickerCollectionComponent.prototype, "label", null);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Array),
        tslib_1.__metadata("design:paramtypes", [Array])
    ], MccColorPickerCollectionComponent.prototype, "colors", null);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Number)
    ], MccColorPickerCollectionComponent.prototype, "size", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Boolean)
    ], MccColorPickerCollectionComponent.prototype, "transparent", void 0);
    tslib_1.__decorate([
        Output(),
        tslib_1.__metadata("design:type", EventEmitter)
    ], MccColorPickerCollectionComponent.prototype, "changeColor", void 0);
    MccColorPickerCollectionComponent = tslib_1.__decorate([
        Component({
            selector: 'mcc-color-picker-collection',
            template: "<div class=\"mcc-color-picker-collection\" role=\"listbox\" aria-label=\"Select a color\">\n        <h3>{{ label }}</h3>\n\n        <button mat-mini-fab *ngIf=\"transparent\" class=\"mcc-color-picker-remove-color mat-elevation-z0\" role=\"option\" aria-label=\"transparent\"\n                (click)=\"setTransparent()\">\n                <div class=\"mcc-color-picker-transparent\"></div>\n        </button>\n\n        <button *ngFor=\"let color of colors\" mat-mini-fab class=\"mat-elevation-z0\" role=\"option\" [disabled]=\"!color || color === emptyColor\"\n                [mccColorPickerOption]=\"color\" (click)=\"setColor(color)\">\n        </button>\n</div>",
            preserveWhitespaces: false,
            changeDetection: ChangeDetectionStrategy.OnPush,
            styles: [".mcc-color-picker-collection{min-height:50px;padding:10px 18px}.mcc-color-picker-collection h3{color:#100214;text-transform:uppercase;font-family:'Open Sans',sans-serif;font-size:12px;font-weight:700;margin:0 0 10px}.mcc-color-picker-remove-color{background-color:#fff;border:1px solid #e1e1e1}.mcc-color-picker-remove-color .mcc-color-picker-transparent{width:20px;height:1px;border-bottom:1px solid red;transform:translateY(-4px) translateX(0) rotate(45deg);-webkit-transform:translateY(-4px) translateX(0) rotate(45deg)}button{width:22px;height:22px;cursor:pointer;margin:3px}"]
        }),
        tslib_1.__param(1, Inject(EMPTY_COLOR)),
        tslib_1.__metadata("design:paramtypes", [ChangeDetectorRef, String])
    ], MccColorPickerCollectionComponent);
    return MccColorPickerCollectionComponent;
}());
export { MccColorPickerCollectionComponent };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29sb3ItcGlja2VyLWNvbGxlY3Rpb24uY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vbWF0ZXJpYWwtY29tbXVuaXR5LWNvbXBvbmVudHMvIiwic291cmNlcyI6WyJjb2xvci1waWNrZXIvY29sb3ItcGlja2VyLWNvbGxlY3Rpb24uY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBRUwsU0FBUyxFQUNULHVCQUF1QixFQUN2QixpQkFBaUIsRUFDakIsWUFBWSxFQUNaLEtBQUssRUFDTCxNQUFNLEVBQ04sTUFBTSxHQUNQLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBQzlELE9BQU8sRUFBRSxXQUFXLEVBQXdCLE1BQU0sZ0JBQWdCLENBQUM7QUFTbkU7SUFrREUsMkNBQ1UsaUJBQW9DLEVBQ2hCLFVBQWtCO1FBRHRDLHNCQUFpQixHQUFqQixpQkFBaUIsQ0FBbUI7UUFDaEIsZUFBVSxHQUFWLFVBQVUsQ0FBUTtRQTNDeEMsZUFBVSxHQUFZLEtBQUssQ0FBQztRQTBCcEM7O1dBRUc7UUFDTSxTQUFJLEdBQVcsRUFBRSxDQUFDO1FBRTNCOztXQUVHO1FBQ00sZ0JBQVcsR0FBWSxLQUFLLENBQUM7UUFFdEM7O1dBRUc7UUFDTyxnQkFBVyxHQUF5QixJQUFJLFlBQVksRUFBVSxDQUFDO0lBS3RFLENBQUM7SUEvQ0osc0JBQUksd0RBQVM7UUFMYjs7O1dBR0c7YUFFSCxVQUFjLEtBQWM7WUFDMUIsSUFBSSxDQUFDLFVBQVUsR0FBRyxxQkFBcUIsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUNqRCxDQUFDOzs7T0FBQTtJQU9ELHNCQUFJLG9EQUFLO1FBSlQ7O1dBRUc7YUFFSDtZQUNFLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQztRQUNyQixDQUFDO2FBQ0QsVUFBVSxLQUFhO1lBQ3JCLElBQUksQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFDO1FBQ3RCLENBQUM7OztPQUhBO0lBVUQsc0JBQUkscURBQU07UUFKVjs7V0FFRzthQUVIO1lBQ0UsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDO1FBQ3RCLENBQUM7YUFDRCxVQUFXLE1BQThCO1lBQ3ZDLElBQUksQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDO1FBQ3hCLENBQUM7OztPQUhBO0lBMEJELGlFQUFxQixHQUFyQjtRQUNFLElBQUksSUFBSSxDQUFDLE9BQU8sSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sS0FBSyxJQUFJLENBQUMsSUFBSSxFQUFFO1lBQ3JELElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLE9BQU87aUJBQ3hCLEtBQUssQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQztpQkFDbkIsTUFBTSxDQUFDLElBQUksS0FBSyxDQUFDLElBQUksQ0FBQyxzQkFBc0IsRUFBRSxDQUFDLENBQUMsQ0FBQztZQUNwRCxJQUFJLENBQUMsaUJBQWlCLENBQUMsWUFBWSxFQUFFLENBQUM7U0FDdkM7SUFDSCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNLLGtFQUFzQixHQUE5QjtRQUNFLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsVUFBVSxFQUFFO1lBQ3RELE9BQU8sQ0FBQyxDQUFDO1NBQ1Y7UUFFRCxPQUFPLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUM7SUFDekMsQ0FBQztJQUVEOztPQUVHO0lBQ0gsMERBQWMsR0FBZDtRQUNFLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUN6QyxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsb0RBQVEsR0FBUixVQUFTLE1BQTRCO1FBQ25DLElBQU0sS0FBSyxHQUFHLE9BQU8sTUFBTSxLQUFLLFFBQVEsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDO1FBQ2pFLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQy9CLENBQUM7SUFyRkQ7UUFEQyxLQUFLLEVBQUU7OztzRUFHUDtJQU9EO1FBREMsS0FBSyxFQUFFOzs7a0VBR1A7SUFVRDtRQURDLEtBQUssRUFBRTs7O21FQUdQO0lBU1E7UUFBUixLQUFLLEVBQUU7O21FQUFtQjtJQUtsQjtRQUFSLEtBQUssRUFBRTs7MEVBQThCO0lBSzVCO1FBQVQsTUFBTSxFQUFFOzBDQUFjLFlBQVk7MEVBQXNDO0lBaEQ5RCxpQ0FBaUM7UUFQN0MsU0FBUyxDQUFDO1lBQ1QsUUFBUSxFQUFFLDZCQUE2QjtZQUN2QyxzcUJBQXVEO1lBRXZELG1CQUFtQixFQUFFLEtBQUs7WUFDMUIsZUFBZSxFQUFFLHVCQUF1QixDQUFDLE1BQU07O1NBQ2hELENBQUM7UUFxREcsbUJBQUEsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFBO2lEQURPLGlCQUFpQjtPQW5EbkMsaUNBQWlDLENBNEY3QztJQUFELHdDQUFDO0NBQUEsQUE1RkQsSUE0RkM7U0E1RlksaUNBQWlDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQWZ0ZXJDb250ZW50Q2hlY2tlZCxcbiAgQ29tcG9uZW50LFxuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gIEV2ZW50RW1pdHRlcixcbiAgSW5wdXQsXG4gIEluamVjdCxcbiAgT3V0cHV0LFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9jb2VyY2lvbic7XG5pbXBvcnQgeyBFTVBUWV9DT0xPUiwgTWNjQ29sb3JQaWNrZXJPcHRpb24gfSBmcm9tICcuL2NvbG9yLXBpY2tlcic7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ21jYy1jb2xvci1waWNrZXItY29sbGVjdGlvbicsXG4gIHRlbXBsYXRlVXJsOiAnLi9jb2xvci1waWNrZXItY29sbGVjdGlvbi5jb21wb25lbnQuaHRtbCcsXG4gIHN0eWxlVXJsczogWycuL2NvbG9yLXBpY2tlci1jb2xsZWN0aW9uLmNvbXBvbmVudC5zY3NzJ10sXG4gIHByZXNlcnZlV2hpdGVzcGFjZXM6IGZhbHNlLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbn0pXG5leHBvcnQgY2xhc3MgTWNjQ29sb3JQaWNrZXJDb2xsZWN0aW9uQ29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJDb250ZW50Q2hlY2tlZCB7XG4gIC8qKlxuICAgKiBIaWRlIGVtcHR5IHNsb3RzXG4gICAqIEVtcHR5IHNsb3RzIGFyZSB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBjb2xsZWN0aW9uIHNpemUgYW5kIGxpbWl0XG4gICAqL1xuICBASW5wdXQoKVxuICBzZXQgaGlkZUVtcHR5KHZhbHVlOiBib29sZWFuKSB7XG4gICAgdGhpcy5faGlkZUVtcHR5ID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTtcbiAgfVxuICBwcml2YXRlIF9oaWRlRW1wdHk6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAvKipcbiAgICogTmFtZSBvZiB0aGUgY29sbGVjdGlvblxuICAgKi9cbiAgQElucHV0KClcbiAgZ2V0IGxhYmVsKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX2xhYmVsO1xuICB9XG4gIHNldCBsYWJlbCh2YWx1ZTogc3RyaW5nKSB7XG4gICAgdGhpcy5fbGFiZWwgPSB2YWx1ZTtcbiAgfVxuICBwcml2YXRlIF9sYWJlbDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBBcnJheSBvZiBjb2xvcnMgdG8gYmUgZGlzcGxheWVkXG4gICAqL1xuICBASW5wdXQoKVxuICBnZXQgY29sb3JzKCk6IE1jY0NvbG9yUGlja2VyT3B0aW9uW10ge1xuICAgIHJldHVybiB0aGlzLl9jb2xvcnM7XG4gIH1cbiAgc2V0IGNvbG9ycyh2YWx1ZXM6IE1jY0NvbG9yUGlja2VyT3B0aW9uW10pIHtcbiAgICB0aGlzLl9jb2xvcnMgPSB2YWx1ZXM7XG4gIH1cbiAgcHJpdmF0ZSBfY29sb3JzOiBNY2NDb2xvclBpY2tlck9wdGlvbltdO1xuXG4gIC8qKlxuICAgKiBTaXplIGxpbWl0IG9mIHRoZSBjb2xsZWN0aW9uXG4gICAqL1xuICBASW5wdXQoKSBzaXplOiBudW1iZXIgPSAzMDtcblxuICAvKipcbiAgICogU2hvdyB0cmFuc3BhcmVudCBvcHRpb25cbiAgICovXG4gIEBJbnB1dCgpIHRyYW5zcGFyZW50OiBib29sZWFuID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIEVtaXQgc2VsZWN0ZWQgY29sb3IgdmFsdWVcbiAgICovXG4gIEBPdXRwdXQoKSBjaGFuZ2VDb2xvcjogRXZlbnRFbWl0dGVyPHN0cmluZz4gPSBuZXcgRXZlbnRFbWl0dGVyPHN0cmluZz4oKTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGNoYW5nZURldGVjdG9yUmVmOiBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICBASW5qZWN0KEVNUFRZX0NPTE9SKSBwdWJsaWMgZW1wdHlDb2xvcjogc3RyaW5nXG4gICkge31cblxuICBuZ0FmdGVyQ29udGVudENoZWNrZWQoKSB7XG4gICAgaWYgKHRoaXMuX2NvbG9ycyAmJiB0aGlzLl9jb2xvcnMubGVuZ3RoICE9PSB0aGlzLnNpemUpIHtcbiAgICAgIHRoaXMuX2NvbG9ycyA9IHRoaXMuX2NvbG9yc1xuICAgICAgICAuc2xpY2UoMCwgdGhpcy5zaXplKVxuICAgICAgICAuY29uY2F0KG5ldyBBcnJheSh0aGlzLl9nZXRDb2xsZWN0aW9uRGlmZlNpemUoKSkpO1xuICAgICAgdGhpcy5jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIGxpbWl0IGFuZCB0aGUgY29sbGVjdGlvbiBzaXplLlxuICAgKiBBbHdheXMgcmV0dXJuIDAgd2hlbiBoaWRlRW1wdHkgaXMgdHJ1ZVxuICAgKiBAcmV0dXJucyBudW1iZXJcbiAgICovXG4gIHByaXZhdGUgX2dldENvbGxlY3Rpb25EaWZmU2l6ZSgpOiBudW1iZXIge1xuICAgIGlmICh0aGlzLl9jb2xvcnMubGVuZ3RoID4gdGhpcy5zaXplIHx8IHRoaXMuX2hpZGVFbXB0eSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc2l6ZSAtIHRoaXMuX2NvbG9ycy5sZW5ndGg7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGNvbG9yXG4gICAqL1xuICBzZXRUcmFuc3BhcmVudCgpOiB2b2lkIHtcbiAgICB0aGlzLmNoYW5nZUNvbG9yLmVtaXQodGhpcy5lbXB0eUNvbG9yKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbWl0IHNlbGVjdGVkIGNvbG9yIHZhbHVlXG4gICAqIEBwYXJhbSBvcHRpb24gTWNjQ29sb3JQaWNrZXJPcHRpb25cbiAgICovXG4gIHNldENvbG9yKG9wdGlvbjogTWNjQ29sb3JQaWNrZXJPcHRpb24pIHtcbiAgICBjb25zdCBjb2xvciA9IHR5cGVvZiBvcHRpb24gPT09ICdzdHJpbmcnID8gb3B0aW9uIDogb3B0aW9uLnZhbHVlO1xuICAgIHRoaXMuY2hhbmdlQ29sb3IuZW1pdChjb2xvcik7XG4gIH1cbn1cbiJdfQ==