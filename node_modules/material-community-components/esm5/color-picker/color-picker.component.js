import * as tslib_1 from "tslib";
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChildren, ElementRef, EventEmitter, Inject, Input, Output, QueryList, } from '@angular/core';
import { BehaviorSubject } from 'rxjs';
import { map } from 'rxjs/operators';
import { EMPTY_COLOR, coerceHexaColor } from './color-picker';
import { MccColorPickerCollectionComponent } from './color-picker-collection.component';
import { MccColorPickerService } from './color-picker.service';
var MccColorPickerComponent = /** @class */ (function () {
    function MccColorPickerComponent(elementRef, changeDetectorRef, colorPickerService, emptyColor) {
        this.elementRef = elementRef;
        this.changeDetectorRef = changeDetectorRef;
        this.colorPickerService = colorPickerService;
        this.emptyColor = emptyColor;
        this._usedColorLabel = 'Used Colors';
        this._reverseUsedColor = false;
        this._hideHexForms = false;
        this._hideEmpty = false;
        this._hideTransparent = false;
        this._hideUsedColors = false;
        this._isOpen = false;
        this._overlay = true;
        this._hideButtons = false;
        this._colorPickerSelectorHeight = 170;
        this._hideColorPickerSelector = false;
        /**
         * Set the size of the used colors
         */
        this.usedSizeColors = 30;
        /**
         * Change btnCancel label
         */
        this.btnCancel = 'Cancel';
        /**
         * Change btnConfirm label
         */
        this.btnConfirm = 'Confirm';
        /**
         * Event emitted when user change the selected color (without confirm)
         */
        this.change = new EventEmitter();
        /**
         * Event emitted when selected color is confirm
         */
        this.selected = new EventEmitter();
        /**
         * Event emitted when is clicked outside of the component
         */
        this.clickOut = new EventEmitter();
        /**
         * Array of subscriptions from the collections
         */
        this._collectionSubs = [];
    }
    Object.defineProperty(MccColorPickerComponent.prototype, "usedColorLabel", {
        /**
         * Change label of the collection UsedColors
         */
        get: function () {
            return this._usedColorLabel;
        },
        set: function (value) {
            this._usedColorLabel = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MccColorPickerComponent.prototype, "usedColorStart", {
        /**
         * Set initial value for used color
         */
        set: function (colors) {
            var e_1, _a;
            if (colors && colors.length > 0) {
                try {
                    for (var colors_1 = tslib_1.__values(colors), colors_1_1 = colors_1.next(); !colors_1_1.done; colors_1_1 = colors_1.next()) {
                        var color = colors_1_1.value;
                        this.colorPickerService.addColor(color);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (colors_1_1 && !colors_1_1.done && (_a = colors_1.return)) _a.call(colors_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MccColorPickerComponent.prototype, "reverseUsedColors", {
        /**
         * Set usedColor to be used in reverse
         */
        set: function (reverse) {
            this._reverseUsedColor = coerceBooleanProperty(reverse);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MccColorPickerComponent.prototype, "hideHexForms", {
        /**
         * Hide the hexadecimal color forms.
         */
        get: function () {
            return this._hideHexForms;
        },
        set: function (value) {
            this._hideHexForms = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MccColorPickerComponent.prototype, "hideEmpty", {
        /**
         * Hide empty slots from the collection UsedColors
         */
        get: function () {
            return this._hideEmpty;
        },
        set: function (value) {
            this._hideEmpty = coerceBooleanProperty(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MccColorPickerComponent.prototype, "hideTransparent", {
        /**
         * Hide transparent option of UsedColors
         */
        get: function () {
            return this._hideTransparent;
        },
        set: function (value) {
            this._hideTransparent = coerceBooleanProperty(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MccColorPickerComponent.prototype, "hideUsedColors", {
        /**
         * Hide UsedColors collection
         */
        get: function () {
            return this._hideUsedColors;
        },
        set: function (value) {
            this._hideUsedColors = coerceBooleanProperty(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MccColorPickerComponent.prototype, "selectedColor", {
        /**
         * Start with a color selected
         */
        get: function () {
            return this._selectedColor;
        },
        set: function (value) {
            if (this._selectedColor !== value) {
                this.changeDetectorRef.markForCheck();
            }
            this._selectedColor = coerceHexaColor(value) || this.emptyColor;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MccColorPickerComponent.prototype, "isOpen", {
        /**
         * Define if the panel will be initiated open
         */
        get: function () {
            return this._isOpen;
        },
        set: function (value) {
            this._isOpen = coerceBooleanProperty(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MccColorPickerComponent.prototype, "overlay", {
        /**
         * Define if the panel will show in overlay or not
         */
        get: function () {
            return this._overlay;
        },
        set: function (value) {
            this._overlay = coerceBooleanProperty(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MccColorPickerComponent.prototype, "hideButtons", {
        /**
         * Hide the action buttons (cancel/confirm)
         */
        get: function () {
            return this._hideButtons;
        },
        set: function (value) {
            this._hideButtons = coerceBooleanProperty(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MccColorPickerComponent.prototype, "colorPickerSelectorHeight", {
        /**
         * Define new height for the selector
         */
        get: function () {
            return this._colorPickerSelectorHeight;
        },
        set: function (height) {
            this._colorPickerSelectorHeight = height;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MccColorPickerComponent.prototype, "hideColorPickerSelector", {
        /**
         * Hide the color picker selector
         */
        get: function () {
            return this._hideColorPickerSelector;
        },
        set: function (value) {
            this._hideColorPickerSelector = coerceBooleanProperty(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MccColorPickerComponent.prototype, "tmpSelectedColor$", {
        /**
         * Return a Observable with the color the user is picking
         */
        get: function () {
            return this._tmpSelectedColor.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MccColorPickerComponent.prototype, "usedColors$", {
        /**
         * Observable with all the colors used by the user
         */
        get: function () {
            var _this = this;
            return this.colorPickerService
                .getColors()
                .pipe(map(function (colors) { return (!_this._reverseUsedColor ? colors : tslib_1.__spread(colors).reverse()); }));
        },
        enumerable: true,
        configurable: true
    });
    MccColorPickerComponent.prototype.ngOnInit = function () {
        if (!this._selectedColor) {
            this._selectedColor = this.emptyColor;
        }
        this._tmpSelectedColor = new BehaviorSubject(this._selectedColor);
    };
    /**
     * Walk throw all collections and subcribe to changes
     */
    MccColorPickerComponent.prototype.ngAfterContentInit = function () {
        var _this = this;
        if (this._collections) {
            this._collections.forEach(function (collection) {
                var subscription = collection.changeColor.subscribe(function (color) {
                    _this.updateTmpSelectedColor(color);
                });
                _this._collectionSubs.push(subscription);
            });
        }
    };
    /**
     * Destroy all subscriptions
     */
    MccColorPickerComponent.prototype.ngOnDestroy = function () {
        if (this._collectionSubs) {
            this._collectionSubs.forEach(function (subscription) {
                if (subscription && !subscription.closed) {
                    subscription.unsubscribe();
                }
            });
        }
    };
    /**
     * Update selected color and emit the change
     */
    MccColorPickerComponent.prototype._updateSelectedColor = function () {
        if (this._isOpen || !this.overlay) {
            var tmpSelectedColor = this._tmpSelectedColor.getValue();
            if (this._selectedColor !== tmpSelectedColor) {
                this._selectedColor = tmpSelectedColor;
                this.selected.next(this._selectedColor);
            }
            else {
                this.selected.emit(this._selectedColor);
            }
        }
    };
    /**
     * Open/close color picker panel
     */
    MccColorPickerComponent.prototype.toggle = function () {
        this._isOpen = !this._isOpen;
        if (!this._isOpen && this._selectedColor !== this.emptyColor) {
            this.colorPickerService.addColor(this._selectedColor);
        }
    };
    /**
     * Update selected color, close the panel and notify the user
     */
    MccColorPickerComponent.prototype.backdropClick = function () {
        if (this._hideButtons) {
            this.confirmSelectedColor();
        }
        else {
            this.cancelSelection();
        }
        this.clickOut.emit(null);
    };
    /**
     * Update tmpSelectedColor
     * @param color string
     */
    MccColorPickerComponent.prototype.updateTmpSelectedColor = function (color) {
        if (color) {
            this._tmpSelectedColor.next(color);
            this.change.next(color);
            if (this._hideButtons) {
                this._updateSelectedColor();
            }
        }
    };
    /**
     * Cancel the selection and close the panel
     */
    MccColorPickerComponent.prototype.cancelSelection = function () {
        this._tmpSelectedColor.next(this._selectedColor);
        this.toggle();
    };
    /**
     * Update selectedColor and close the panel
     */
    MccColorPickerComponent.prototype.confirmSelectedColor = function () {
        this._updateSelectedColor();
        this.toggle();
    };
    tslib_1.__decorate([
        ContentChildren(MccColorPickerCollectionComponent),
        tslib_1.__metadata("design:type", QueryList)
    ], MccColorPickerComponent.prototype, "_collections", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", String),
        tslib_1.__metadata("design:paramtypes", [String])
    ], MccColorPickerComponent.prototype, "usedColorLabel", null);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Array),
        tslib_1.__metadata("design:paramtypes", [Array])
    ], MccColorPickerComponent.prototype, "usedColorStart", null);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Boolean),
        tslib_1.__metadata("design:paramtypes", [Boolean])
    ], MccColorPickerComponent.prototype, "reverseUsedColors", null);
    tslib_1.__decorate([
        Input('hideHexForms'),
        tslib_1.__metadata("design:type", Boolean),
        tslib_1.__metadata("design:paramtypes", [Boolean])
    ], MccColorPickerComponent.prototype, "hideHexForms", null);
    tslib_1.__decorate([
        Input('hideEmptyUsedColors'),
        tslib_1.__metadata("design:type", Boolean),
        tslib_1.__metadata("design:paramtypes", [Boolean])
    ], MccColorPickerComponent.prototype, "hideEmpty", null);
    tslib_1.__decorate([
        Input('hideTransparentUsedColors'),
        tslib_1.__metadata("design:type", Boolean),
        tslib_1.__metadata("design:paramtypes", [Boolean])
    ], MccColorPickerComponent.prototype, "hideTransparent", null);
    tslib_1.__decorate([
        Input('hideUsedColors'),
        tslib_1.__metadata("design:type", Boolean),
        tslib_1.__metadata("design:paramtypes", [Boolean])
    ], MccColorPickerComponent.prototype, "hideUsedColors", null);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", String),
        tslib_1.__metadata("design:paramtypes", [String])
    ], MccColorPickerComponent.prototype, "selectedColor", null);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Boolean),
        tslib_1.__metadata("design:paramtypes", [Boolean])
    ], MccColorPickerComponent.prototype, "isOpen", null);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Boolean),
        tslib_1.__metadata("design:paramtypes", [Boolean])
    ], MccColorPickerComponent.prototype, "overlay", null);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Boolean),
        tslib_1.__metadata("design:paramtypes", [Boolean])
    ], MccColorPickerComponent.prototype, "hideButtons", null);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Number),
        tslib_1.__metadata("design:paramtypes", [Number])
    ], MccColorPickerComponent.prototype, "colorPickerSelectorHeight", null);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Boolean),
        tslib_1.__metadata("design:paramtypes", [Boolean])
    ], MccColorPickerComponent.prototype, "hideColorPickerSelector", null);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Number)
    ], MccColorPickerComponent.prototype, "usedSizeColors", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", String)
    ], MccColorPickerComponent.prototype, "btnCancel", void 0);
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", String)
    ], MccColorPickerComponent.prototype, "btnConfirm", void 0);
    tslib_1.__decorate([
        Output(),
        tslib_1.__metadata("design:type", Object)
    ], MccColorPickerComponent.prototype, "change", void 0);
    tslib_1.__decorate([
        Output(),
        tslib_1.__metadata("design:type", Object)
    ], MccColorPickerComponent.prototype, "selected", void 0);
    tslib_1.__decorate([
        Output(),
        tslib_1.__metadata("design:type", Object)
    ], MccColorPickerComponent.prototype, "clickOut", void 0);
    MccColorPickerComponent = tslib_1.__decorate([
        Component({
            selector: 'mcc-color-picker',
            template: "<!-- color picker overlay -->\n<ng-container *ngIf=\"overlay\">\n    <button type=\"button\" class=\"btn-picker\" cdkOverlayOrigin #trigger=\"cdkOverlayOrigin\" [ngClass]=\"{ 'empty': selectedColor === emptyColor }\"\n        [style.background]=\"selectedColor\" (click)=\"toggle()\">\n        <div class=\"transparent\" *ngIf=\"selectedColor === emptyColor\"></div>\n    </button>\n\n    <ng-template cdkConnectedOverlay cdkConnectedOverlayHasBackdrop cdkConnectedOverlayBackdropClass=\"mcc-color-picker-backdrop\"\n        [cdkConnectedOverlayOrigin]=\"trigger\" [cdkConnectedOverlayOpen]=\"isOpen\" (backdropClick)=\"backdropClick()\">\n\n        <ng-template [cdkPortalOutlet]=\"overlayPanel\"></ng-template>\n\n    </ng-template>\n</ng-container>\n\n<!-- color picker flat -->\n<ng-template *ngIf=\"!overlay\" [cdkPortalOutlet]=\"overlayPanel\"></ng-template>\n\n<!-- color picker component content -->\n<ng-template cdkPortal #overlayPanel=\"cdkPortal\">\n\n    <div class=\"mcc-color-picker-overlay mat-elevation-z6\" role=\"dialog\" aria-label=\"Color picker\">\n\n        <mcc-color-picker-selector *ngIf=\"!hideColorPickerSelector\" [selectedColor]=\"tmpSelectedColor$ | async\" [hideHexForms]=\"hideHexForms\"\n            [height]=\"colorPickerSelectorHeight\" (changeSelectedColor)=\"updateTmpSelectedColor($event)\">\n        </mcc-color-picker-selector>\n\n        <mcc-color-picker-collection *ngIf=\"!hideUsedColors\" [label]=\"usedColorLabel\" [size]=\"usedSizeColors\" [transparent]=\"!hideTransparent\"\n            [hideEmpty]=\"hideEmpty\" [colors]=\"usedColors$ | async\" (changeColor)=\"updateTmpSelectedColor($event)\">\n        </mcc-color-picker-collection>\n\n        <ng-content></ng-content>\n\n        <div *ngIf=\"!hideButtons\" class=\"mcc-color-picker-actions\">\n\n            <button mat-button role=\"button\" aria-label=\"Cancel\" (click)=\"cancelSelection()\">\n                {{ btnCancel }}\n            </button>\n\n            <button mat-button role=\"button\" aria-label=\"Confirm\" (click)=\"confirmSelectedColor()\">\n                {{ btnConfirm }}\n            </button>\n\n        </div>\n\n    </div>\n\n</ng-template>",
            preserveWhitespaces: false,
            changeDetection: ChangeDetectionStrategy.OnPush,
            styles: ["@import url(https://fonts.googleapis.com/css?family=Open+Sans:400,700);.btn-picker{width:25px;height:25px;cursor:pointer;background:0 0;border:2px solid #ddd}.btn-picker.empty{background:#fff!important}.mcc-color-picker-overlay{display:flex;width:260px;min-height:80px;position:relative;flex-direction:column;padding:0;background:#fff;font-family:'Open Sans',sans-serif}.mcc-color-picker-overlay .mcc-color-picker-preview{width:100%;height:8px}.transparent{width:32px;height:2px;border-bottom:2px solid red;transform:translateY(-3px) translateX(-2px) rotate(45deg);-webkit-transform:translateY(-2px) translateX(-11px) rotate(45deg);position:absolute}.mcc-color-picker-actions{display:flex;padding:4px;border-top:1px solid #ddd}.mcc-color-picker-actions button{color:#100214;text-transform:uppercase;font-family:'Open Sans',sans-serif;font-size:12px;font-weight:400;flex-grow:1}"]
        }),
        tslib_1.__param(3, Inject(EMPTY_COLOR)),
        tslib_1.__metadata("design:paramtypes", [ElementRef,
            ChangeDetectorRef,
            MccColorPickerService, String])
    ], MccColorPickerComponent);
    return MccColorPickerComponent;
}());
export { MccColorPickerComponent };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29sb3ItcGlja2VyLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL21hdGVyaWFsLWNvbW11bml0eS1jb21wb25lbnRzLyIsInNvdXJjZXMiOlsiY29sb3ItcGlja2VyL2NvbG9yLXBpY2tlci5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBQzlELE9BQU8sRUFFTCx1QkFBdUIsRUFDdkIsaUJBQWlCLEVBQ2pCLFNBQVMsRUFDVCxlQUFlLEVBQ2YsVUFBVSxFQUNWLFlBQVksRUFDWixNQUFNLEVBQ04sS0FBSyxFQUdMLE1BQU0sRUFDTixTQUFTLEdBQ1YsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLGVBQWUsRUFBNEIsTUFBTSxNQUFNLENBQUM7QUFDakUsT0FBTyxFQUFFLEdBQUcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3JDLE9BQU8sRUFBRSxXQUFXLEVBQUUsZUFBZSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDOUQsT0FBTyxFQUFFLGlDQUFpQyxFQUFFLE1BQU0scUNBQXFDLENBQUM7QUFDeEYsT0FBTyxFQUFFLHFCQUFxQixFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFTL0Q7SUF3TkUsaUNBQ1UsVUFBc0IsRUFDdEIsaUJBQW9DLEVBQ3BDLGtCQUF5QyxFQUNyQixVQUFrQjtRQUh0QyxlQUFVLEdBQVYsVUFBVSxDQUFZO1FBQ3RCLHNCQUFpQixHQUFqQixpQkFBaUIsQ0FBbUI7UUFDcEMsdUJBQWtCLEdBQWxCLGtCQUFrQixDQUF1QjtRQUNyQixlQUFVLEdBQVYsVUFBVSxDQUFRO1FBM014QyxvQkFBZSxHQUFXLGFBQWEsQ0FBQztRQXFCeEMsc0JBQWlCLEdBQVksS0FBSyxDQUFDO1FBWW5DLGtCQUFhLEdBQVksS0FBSyxDQUFDO1FBWS9CLGVBQVUsR0FBWSxLQUFLLENBQUM7UUFZNUIscUJBQWdCLEdBQVksS0FBSyxDQUFD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QUd2QjtJQVVEO1FBREMsS0FBSyxFQUFFOzs7Z0VBR1A7SUFjRDtRQURDLEtBQUssRUFBRTs7O3lEQUdQO0lBVUQ7UUFEQyxLQUFLLEVBQUU7OzswREFHUDtJQVVEO1FBREMsS0FBSyxFQUFFOzs7OERBR1A7SUFVRDtRQURDLEtBQUssRUFBRTs7OzRFQUdQO0lBVUQ7UUFEQyxLQUFLLEVBQUU7OzswRUFHUDtJQVNRO1FBQVIsS0FBSyxFQUFFOzttRUFBNkI7SUFLNUI7UUFBUixLQUFLLEVBQUU7OzhEQUE4QjtJQUs3QjtRQUFSLEtBQUssRUFBRTs7K0RBQWdDO0lBSzlCO1FBQVQsTUFBTSxFQUFFOzsyREFBNkI7SUFLNUI7UUFBVCxNQUFNLEVBQUU7OzZEQUErQjtJQUs5QjtRQUFULE1BQU0sRUFBRTs7NkRBQStCO0lBaE03Qix1QkFBdUI7UUFQbkMsU0FBUyxDQUFDO1lBQ1QsUUFBUSxFQUFFLGtCQUFrQjtZQUM1Qix1b0VBQTRDO1lBRTVDLG1CQUFtQixFQUFFLEtBQUs7WUFDMUIsZUFBZSxFQUFFLHVCQUF1QixDQUFDLE1BQU07O1NBQ2hELENBQUM7UUE2TkcsbUJBQUEsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFBO2lEQUhBLFVBQVU7WUFDSCxpQkFBaUI7WUFDaEIscUJBQXFCO09BM054Qyx1QkFBdUIsQ0FxVW5DO0lBQUQsOEJBQUM7Q0FBQSxBQXJVRCxJQXFVQztTQXJVWSx1QkFBdUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjb2VyY2VCb29sZWFuUHJvcGVydHkgfSBmcm9tICdAYW5ndWxhci9jZGsvY29lcmNpb24nO1xuaW1wb3J0IHtcbiAgQWZ0ZXJDb250ZW50SW5pdCxcbiAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gIENoYW5nZURldGVjdG9yUmVmLFxuICBDb21wb25lbnQsXG4gIENvbnRlbnRDaGlsZHJlbixcbiAgRWxlbWVudFJlZixcbiAgRXZlbnRFbWl0dGVyLFxuICBJbmplY3QsXG4gIElucHV0LFxuICBPbkRlc3Ryb3ksXG4gIE9uSW5pdCxcbiAgT3V0cHV0LFxuICBRdWVyeUxpc3QsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0LCBPYnNlcnZhYmxlLCBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IG1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IEVNUFRZX0NPTE9SLCBjb2VyY2VIZXhhQ29sb3IgfSBmcm9tICcuL2NvbG9yLXBpY2tlcic7XG5pbXBvcnQgeyBNY2NDb2xvclBpY2tlckNvbGxlY3Rpb25Db21wb25lbnQgfSBmcm9tICcuL2NvbG9yLXBpY2tlci1jb2xsZWN0aW9uLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBNY2NDb2xvclBpY2tlclNlcnZpY2UgfSBmcm9tICcuL2NvbG9yLXBpY2tlci5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnbWNjLWNvbG9yLXBpY2tlcicsXG4gIHRlbXBsYXRlVXJsOiAnLi9jb2xvci1waWNrZXIuY29tcG9uZW50Lmh0bWwnLFxuICBzdHlsZVVybHM6IFsnLi9jb2xvci1waWNrZXIuY29tcG9uZW50LnNjc3MnXSxcbiAgcHJlc2VydmVXaGl0ZXNwYWNlczogZmFsc2UsXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxufSlcbmV4cG9ydCBjbGFzcyBNY2NDb2xvclBpY2tlckNvbXBvbmVudCBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXQsIE9uSW5pdCwgT25EZXN0cm95IHtcbiAgLyoqXG4gICAqIEdldCBhbGwgY29sbGVjdGlvbnNcbiAgICovXG4gIEBDb250ZW50Q2hpbGRyZW4oTWNjQ29sb3JQaWNrZXJDb2xsZWN0aW9uQ29tcG9uZW50KVxuICBfY29sbGVjdGlvbnM6IFF1ZXJ5TGlzdDxNY2NDb2xvclBpY2tlckNvbGxlY3Rpb25Db21wb25lbnQ+O1xuXG4gIC8qKlxuICAgKiBDaGFuZ2UgbGFiZWwgb2YgdGhlIGNvbGxlY3Rpb24gVXNlZENvbG9yc1xuICAgKi9cbiAgQElucHV0KClcbiAgZ2V0IHVzZWRDb2xvckxhYmVsKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX3VzZWRDb2xvckxhYmVsO1xuICB9XG4gIHNldCB1c2VkQ29sb3JMYWJlbCh2YWx1ZTogc3RyaW5nKSB7XG4gICAgdGhpcy5fdXNlZENvbG9yTGFiZWwgPSB2YWx1ZTtcbiAgfVxuICBwcml2YXRlIF91c2VkQ29sb3JMYWJlbDogc3RyaW5nID0gJ1VzZWQgQ29sb3JzJztcblxuICAvKipcbiAgICogU2V0IGluaXRpYWwgdmFsdWUgZm9yIHVzZWQgY29sb3JcbiAgICovXG4gIEBJbnB1dCgpXG4gIHNldCB1c2VkQ29sb3JTdGFydChjb2xvcnM6IHN0cmluZ1tdKSB7XG4gICAgaWYgKGNvbG9ycyAmJiBjb2xvcnMubGVuZ3RoID4gMCkge1xuICAgICAgZm9yIChjb25zdCBjb2xvciBvZiBjb2xvcnMpIHtcbiAgICAgICAgdGhpcy5jb2xvclBpY2tlclNlcnZpY2UuYWRkQ29sb3IoY29sb3IpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdXNlZENvbG9yIHRvIGJlIHVzZWQgaW4gcmV2ZXJzZVxuICAgKi9cbiAgQElucHV0KClcbiAgc2V0IHJldmVyc2VVc2VkQ29sb3JzKHJldmVyc2U6IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9yZXZlcnNlVXNlZENvbG9yID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHJldmVyc2UpO1xuICB9XG4gIHByaXZhdGUgX3JldmVyc2VVc2VkQ29sb3I6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAvKipcbiAgICogSGlkZSB0aGUgaGV4YWRlY2ltYWwgY29sb3IgZm9ybXMuXG4gICAqL1xuICBASW5wdXQoJ2hpZGVIZXhGb3JtcycpXG4gIGdldCBoaWRlSGV4Rm9ybXMoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX2hpZGVIZXhGb3JtcztcbiAgfVxuICBzZXQgaGlkZUhleEZvcm1zKHZhbHVlOiBib29sZWFuKSB7XG4gICAgdGhpcy5faGlkZUhleEZvcm1zID0gdmFsdWU7XG4gIH1cbiAgcHJpdmF0ZSBfaGlkZUhleEZvcm1zOiBib29sZWFuID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIEhpZGUgZW1wdHkgc2xvdHMgZnJvbSB0aGUgY29sbGVjdGlvbiBVc2VkQ29sb3JzXG4gICAqL1xuICBASW5wdXQoJ2hpZGVFbXB0eVVzZWRDb2xvcnMnKVxuICBnZXQgaGlkZUVtcHR5KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9oaWRlRW1wdHk7XG4gIH1cbiAgc2V0IGhpZGVFbXB0eSh2YWx1ZTogYm9vbGVhbikge1xuICAgIHRoaXMuX2hpZGVFbXB0eSA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7XG4gIH1cbiAgcHJpdmF0ZSBfaGlkZUVtcHR5OiBib29sZWFuID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIEhpZGUgdHJhbnNwYXJlbnQgb3B0aW9uIG9mIFVzZWRDb2xvcnNcbiAgICovXG4gIEBJbnB1dCgnaGlkZVRyYW5zcGFyZW50VXNlZENvbG9ycycpXG4gIGdldCBoaWRlVHJhbnNwYXJlbnQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX2hpZGVUcmFuc3BhcmVudDtcbiAgfVxuICBzZXQgaGlkZVRyYW5zcGFyZW50KHZhbHVlOiBib29sZWFuKSB7XG4gICAgdGhpcy5faGlkZVRyYW5zcGFyZW50ID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTtcbiAgfVxuICBwcml2YXRlIF9oaWRlVHJhbnNwYXJlbnQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAvKipcbiAgICogSGlkZSBVc2VkQ29sb3JzIGNvbGxlY3Rpb25cbiAgICovXG4gIEBJbnB1dCgnaGlkZVVzZWRDb2xvcnMnKVxuICBnZXQgaGlkZVVzZWRDb2xvcnMoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX2hpZGVVc2VkQ29sb3JzO1xuICB9XG4gIHNldCBoaWRlVXNlZENvbG9ycyh2YWx1ZTogYm9vbGVhbikge1xuICAgIHRoaXMuX2hpZGVVc2VkQ29sb3JzID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTtcbiAgfVxuICBwcml2YXRlIF9oaWRlVXNlZENvbG9yczogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBTdGFydCB3aXRoIGEgY29sb3Igc2VsZWN0ZWRcbiAgICovXG4gIEBJbnB1dCgpXG4gIGdldCBzZWxlY3RlZENvbG9yKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX3NlbGVjdGVkQ29sb3I7XG4gIH1cbiAgc2V0IHNlbGVjdGVkQ29sb3IodmFsdWU6IHN0cmluZykge1xuICAgIGlmICh0aGlzLl9zZWxlY3RlZENvbG9yICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG5cbiAgICB0aGlzLl9zZWxlY3RlZENvbG9yID0gY29lcmNlSGV4YUNvbG9yKHZhbHVlKSB8fCB0aGlzLmVtcHR5Q29sb3I7XG4gIH1cbiAgcHJpdmF0ZSBfc2VsZWN0ZWRDb2xvcjogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBEZWZpbmUgaWYgdGhlIHBhbmVsIHdpbGwgYmUgaW5pdGlhdGVkIG9wZW5cbiAgICovXG4gIEBJbnB1dCgpXG4gIGdldCBpc09wZW4oKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX2lzT3BlbjtcbiAgfVxuICBzZXQgaXNPcGVuKHZhbHVlOiBib29sZWFuKSB7XG4gICAgdGhpcy5faXNPcGVuID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTtcbiAgfVxuICBwcml2YXRlIF9pc09wZW46IGJvb2xlYW4gPSBmYWxzZTtcblxuICAvKipcbiAgICogRGVmaW5lIGlmIHRoZSBwYW5lbCB3aWxsIHNob3cgaW4gb3ZlcmxheSBvciBub3RcbiAgICovXG4gIEBJbnB1dCgpXG4gIGdldCBvdmVybGF5KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9vdmVybGF5O1xuICB9XG4gIHNldCBvdmVybGF5KHZhbHVlOiBib29sZWFuKSB7XG4gICAgdGhpcy5fb3ZlcmxheSA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7XG4gIH1cbiAgcHJpdmF0ZSBfb3ZlcmxheTogYm9vbGVhbiA9IHRydWU7XG5cbiAgLyoqXG4gICAqIEhpZGUgdGhlIGFjdGlvbiBidXR0b25zIChjYW5jZWwvY29uZmlybSlcbiAgICovXG4gIEBJbnB1dCgpXG4gIGdldCBoaWRlQnV0dG9ucygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5faGlkZUJ1dHRvbnM7XG4gIH1cbiAgc2V0IGhpZGVCdXR0b25zKHZhbHVlOiBib29sZWFuKSB7XG4gICAgdGhpcy5faGlkZUJ1dHRvbnMgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpO1xuICB9XG4gIHByaXZhdGUgX2hpZGVCdXR0b25zOiBib29sZWFuID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIERlZmluZSBuZXcgaGVpZ2h0IGZvciB0aGUgc2VsZWN0b3JcbiAgICovXG4gIEBJbnB1dCgpXG4gIGdldCBjb2xvclBpY2tlclNlbGVjdG9ySGVpZ2h0KCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbG9yUGlja2VyU2VsZWN0b3JIZWlnaHQ7XG4gIH1cbiAgc2V0IGNvbG9yUGlja2VyU2VsZWN0b3JIZWlnaHQoaGVpZ2h0OiBudW1iZXIpIHtcbiAgICB0aGlzLl9jb2xvclBpY2tlclNlbGVjdG9ySGVpZ2h0ID0gaGVpZ2h0O1xuICB9XG4gIHByaXZhdGUgX2NvbG9yUGlja2VyU2VsZWN0b3JIZWlnaHQ6IG51bWJlciA9IDE3MDtcblxuICAvKipcbiAgICogSGlkZSB0aGUgY29sb3IgcGlja2VyIHNlbGVjdG9yXG4gICAqL1xuICBASW5wdXQoKVxuICBnZXQgaGlkZUNvbG9yUGlja2VyU2VsZWN0b3IoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX2hpZGVDb2xvclBpY2tlclNlbGVjdG9yO1xuICB9XG4gIHNldCBoaWRlQ29sb3JQaWNrZXJTZWxlY3Rvcih2YWx1ZTogYm9vbGVhbikge1xuICAgIHRoaXMuX2hpZGVDb2xvclBpY2tlclNlbGVjdG9yID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTtcbiAgfVxuICBwcml2YXRlIF9oaWRlQ29sb3JQaWNrZXJTZWxlY3RvcjogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHNpemUgb2YgdGhlIHVzZWQgY29sb3JzXG4gICAqL1xuICBASW5wdXQoKSB1c2VkU2l6ZUNvbG9yczogbnVtYmVyID0gMzA7XG5cbiAgLyoqXG4gICAqIENoYW5nZSBidG5DYW5jZWwgbGFiZWxcbiAgICovXG4gIEBJbnB1dCgpIGJ0bkNhbmNlbDogc3RyaW5nID0gJ0NhbmNlbCc7XG5cbiAgLyoqXG4gICAqIENoYW5nZSBidG5Db25maXJtIGxhYmVsXG4gICAqL1xuICBASW5wdXQoKSBidG5Db25maXJtOiBzdHJpbmcgPSAnQ29uZmlybSc7XG5cbiAgLyoqXG4gICAqIEV2ZW50IGVtaXR0ZWQgd2hlbiB1c2VyIGNoYW5nZSB0aGUgc2VsZWN0ZWQgY29sb3IgKHdpdGhvdXQgY29uZmlybSlcbiAgICovXG4gIEBPdXRwdXQoKSBjaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgLyoqXG4gICAqIEV2ZW50IGVtaXR0ZWQgd2hlbiBzZWxlY3RlZCBjb2xvciBpcyBjb25maXJtXG4gICAqL1xuICBAT3V0cHV0KCkgc2VsZWN0ZWQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgLyoqXG4gICAqIEV2ZW50IGVtaXR0ZWQgd2hlbiBpcyBjbGlja2VkIG91dHNpZGUgb2YgdGhlIGNvbXBvbmVudFxuICAgKi9cbiAgQE91dHB1dCgpIGNsaWNrT3V0ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBPYnNlcnZhYmxlIHdpdGggdGhlIGNvbG9yIHRoZSB1c2VyIGlzIHBpY2tpbmdcbiAgICovXG4gIGdldCB0bXBTZWxlY3RlZENvbG9yJCgpOiBPYnNlcnZhYmxlPHN0cmluZz4ge1xuICAgIHJldHVybiB0aGlzLl90bXBTZWxlY3RlZENvbG9yLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG4gIHByaXZhdGUgX3RtcFNlbGVjdGVkQ29sb3I6IEJlaGF2aW9yU3ViamVjdDxzdHJpbmc+O1xuXG4gIC8qKlxuICAgKiBPYnNlcnZhYmxlIHdpdGggYWxsIHRoZSBjb2xvcnMgdXNlZCBieSB0aGUgdXNlclxuICAgKi9cbiAgZ2V0IHVzZWRDb2xvcnMkKCk6IE9ic2VydmFibGU8c3RyaW5nW10+IHtcbiAgICByZXR1cm4gdGhpcy5jb2xvclBpY2tlclNlcnZpY2VcbiAgICAgIC5nZXRDb2xvcnMoKVxuICAgICAgLnBpcGUobWFwKGNvbG9ycyA9PiAoIXRoaXMuX3JldmVyc2VVc2VkQ29sb3IgPyBjb2xvcnMgOiBbLi4uY29sb3JzXS5yZXZlcnNlKCkpKSk7XG4gIH1cblxuICAvKipcbiAgICogQXJyYXkgb2Ygc3Vic2NyaXB0aW9ucyBmcm9tIHRoZSBjb2xsZWN0aW9uc1xuICAgKi9cbiAgcHJpdmF0ZSBfY29sbGVjdGlvblN1YnM6IFN1YnNjcmlwdGlvbltdID0gW107XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBlbGVtZW50UmVmOiBFbGVtZW50UmVmLFxuICAgIHByaXZhdGUgY2hhbmdlRGV0ZWN0b3JSZWY6IENoYW5nZURldGVjdG9yUmVmLFxuICAgIHByaXZhdGUgY29sb3JQaWNrZXJTZXJ2aWNlOiBNY2NDb2xvclBpY2tlclNlcnZpY2UsXG4gICAgQEluamVjdChFTVBUWV9DT0xPUikgcHVibGljIGVtcHR5Q29sb3I6IHN0cmluZ1xuICApIHt9XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgaWYgKCF0aGlzLl9zZWxlY3RlZENvbG9yKSB7XG4gICAgICB0aGlzLl9zZWxlY3RlZENvbG9yID0gdGhpcy5lbXB0eUNvbG9yO1xuICAgIH1cblxuICAgIHRoaXMuX3RtcFNlbGVjdGVkQ29sb3IgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PHN0cmluZz4odGhpcy5fc2VsZWN0ZWRDb2xvcik7XG4gIH1cblxuICAvKipcbiAgICogV2FsayB0aHJvdyBhbGwgY29sbGVjdGlvbnMgYW5kIHN1YmNyaWJlIHRvIGNoYW5nZXNcbiAgICovXG4gIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICBpZiAodGhpcy5fY29sbGVjdGlvbnMpIHtcbiAgICAgIHRoaXMuX2NvbGxlY3Rpb25zLmZvckVhY2goKGNvbGxlY3Rpb246IE1jY0NvbG9yUGlja2VyQ29sbGVjdGlvbkNvbXBvbmVudCkgPT4ge1xuICAgICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBjb2xsZWN0aW9uLmNoYW5nZUNvbG9yLnN1YnNjcmliZShjb2xvciA9PiB7XG4gICAgICAgICAgdGhpcy51cGRhdGVUbXBTZWxlY3RlZENvbG9yKGNvbG9yKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5fY29sbGVjdGlvblN1YnMucHVzaChzdWJzY3JpcHRpb24pO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERlc3Ryb3kgYWxsIHN1YnNjcmlwdGlvbnNcbiAgICovXG4gIG5nT25EZXN0cm95KCkge1xuICAgIGlmICh0aGlzLl9jb2xsZWN0aW9uU3Vicykge1xuICAgICAgdGhpcy5fY29sbGVjdGlvblN1YnMuZm9yRWFjaCgoc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb24pID0+IHtcbiAgICAgICAgaWYgKHN1YnNjcmlwdGlvbiAmJiAhc3Vic2NyaXB0aW9uLmNsb3NlZCkge1xuICAgICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHNlbGVjdGVkIGNvbG9yIGFuZCBlbWl0IHRoZSBjaGFuZ2VcbiAgICovXG4gIHByaXZhdGUgX3VwZGF0ZVNlbGVjdGVkQ29sb3IoKSB7XG4gICAgaWYgKHRoaXMuX2lzT3BlbiB8fCAhdGhpcy5vdmVybGF5KSB7XG4gICAgICBjb25zdCB0bXBTZWxlY3RlZENvbG9yID0gdGhpcy5fdG1wU2VsZWN0ZWRDb2xvci5nZXRWYWx1ZSgpO1xuICAgICAgaWYgKHRoaXMuX3NlbGVjdGVkQ29sb3IgIT09IHRtcFNlbGVjdGVkQ29sb3IpIHtcbiAgICAgICAgdGhpcy5fc2VsZWN0ZWRDb2xvciA9IHRtcFNlbGVjdGVkQ29sb3I7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWQubmV4dCh0aGlzLl9zZWxlY3RlZENvbG9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWQuZW1pdCh0aGlzLl9zZWxlY3RlZENvbG9yKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogT3Blbi9jbG9zZSBjb2xvciBwaWNrZXIgcGFuZWxcbiAgICovXG4gIHRvZ2dsZSgpIHtcbiAgICB0aGlzLl9pc09wZW4gPSAhdGhpcy5faXNPcGVuO1xuICAgIGlmICghdGhpcy5faXNPcGVuICYmIHRoaXMuX3NlbGVjdGVkQ29sb3IgIT09IHRoaXMuZW1wdHlDb2xvcikge1xuICAgICAgdGhpcy5jb2xvclBpY2tlclNlcnZpY2UuYWRkQ29sb3IodGhpcy5fc2VsZWN0ZWRDb2xvcik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBzZWxlY3RlZCBjb2xvciwgY2xvc2UgdGhlIHBhbmVsIGFuZCBub3RpZnkgdGhlIHVzZXJcbiAgICovXG4gIGJhY2tkcm9wQ2xpY2soKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuX2hpZGVCdXR0b25zKSB7XG4gICAgICB0aGlzLmNvbmZpcm1TZWxlY3RlZENvbG9yKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2FuY2VsU2VsZWN0aW9uKCk7XG4gICAgfVxuICAgIHRoaXMuY2xpY2tPdXQuZW1pdChudWxsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdG1wU2VsZWN0ZWRDb2xvclxuICAgKiBAcGFyYW0gY29sb3Igc3RyaW5nXG4gICAqL1xuICB1cGRhdGVUbXBTZWxlY3RlZENvbG9yKGNvbG9yOiBzdHJpbmcpIHtcbiAgICBpZiAoY29sb3IpIHtcbiAgICAgIHRoaXMuX3RtcFNlbGVjdGVkQ29sb3IubmV4dChjb2xvcik7XG4gICAgICB0aGlzLmNoYW5nZS5uZXh0KGNvbG9yKTtcbiAgICAgIGlmICh0aGlzLl9oaWRlQnV0dG9ucykge1xuICAgICAgICB0aGlzLl91cGRhdGVTZWxlY3RlZENvbG9yKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbmNlbCB0aGUgc2VsZWN0aW9uIGFuZCBjbG9zZSB0aGUgcGFuZWxcbiAgICovXG4gIGNhbmNlbFNlbGVjdGlvbigpIHtcbiAgICB0aGlzLl90bXBTZWxlY3RlZENvbG9yLm5leHQodGhpcy5fc2VsZWN0ZWRDb2xvcik7XG4gICAgdGhpcy50b2dnbGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgc2VsZWN0ZWRDb2xvciBhbmQgY2xvc2UgdGhlIHBhbmVsXG4gICAqL1xuICBjb25maXJtU2VsZWN0ZWRDb2xvcigpIHtcbiAgICB0aGlzLl91cGRhdGVTZWxlY3RlZENvbG9yKCk7XG4gICAgdGhpcy50b2dnbGUoKTtcbiAgfVxufVxuIl19